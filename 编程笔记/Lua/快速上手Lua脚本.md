## 前言
我学习Lua的目的是为了在 redis 中使用它，这样可以保证多条命令的原子性。Redis 允许用户在服务器上上传和执行 Lua 脚本。脚本可以使用编程控制结构，并在执行时使用大多数命令来访问数据库。由于脚本在服务器中执行，因此从脚本读取和写入数据非常高效。

> Redis 保证脚本的原子执行。在执行脚本时，所有服务器活动在其整个运行期间都被阻止。这些语义意味着脚本的所有效果要么尚未发生，要么已经发生。

具体属性如下：
- 通过在数据所在的位置执行逻辑来提供局部性。数据局部性可减少总体延迟并节省网络资源。
- 确保脚本原子执行的阻塞语义。
- 支持 Redis 所缺少或过于小众的简单功能的组合。

注意：
脚本由 Redis 中的嵌入式执行引擎执行。目前，Redis 支持单个脚本引擎，即Lua 5.1解释器。
[Redis Lua API 参考手册](https://redis.io/docs/latest/develop/interact/programmability/lua-api)

尽管服务器会执行这些脚本，但 Eval 脚本被视为客户端应用程序的一部分，这就是为什么它们没有命名、版本控制或持久化的原因。因此，如果缺少脚本（服务器重启、故障转移到副本等），应用程序可能需要随时重新加载所有脚本。从 7.0 版开始，Redis 函数提供了一种可编程性的替代方法，允许使用其他编程逻辑扩展服务器本身。

## 入门
我们将使用命令开始使用 Redis 编写脚本EVAL。例如：
```bash
EVAL "return 'Hello, scripting!'" 0

# "Hello, scripting!"
```
`EVAL` 函数接收两个参数：第一个是执行的 Lua 脚本程序，第二个是Redis 键名数量，
后面跟上对应数量的键名序列，然后是参数序列。，这里的 0 表示没有提供任何键名参数，所以后面就不需要写任何键名了。

> 提示：通常我们是程序里面动态生成 Lua 程序脚本执行。

```bash
EVAL "return { KEYS[1], KEYS[2], ARGV[1], ARGV[2], ARGV[3] }" 2 key1 key2 arg1 arg2 arg3
1) "key1"
2) "key2"
3) "arg1"
4) "arg2"
5) "arg3"
```
这里表示后面的序列中前面两个是键名，然后其他的都是参数。

### Lua 脚本中调用 redis 命令
```bash
EVAL "return redis.call('PING')" 0
# PONG
```

### 脚本缓存
到目前为止，我们已经使用EVAL命令来运行我们的脚本。

每当我们调用时EVAL，我们还会将脚本的源代码包含在请求中。反复调用EVAL以执行同一组参数化脚本，既浪费网络带宽，又会在 Redis 中产生一些开销。当然，节省网络和计算资源是关键，因此，Redis 为脚本提供了缓存机制。

您执行的每个脚本都EVAL存储在服务器保留的专用缓存中。缓存的内容由脚本的 SHA1 摘要和组织，因此脚本的 SHA1 摘要和在缓存中唯一标识它。您可以通过运行EVAL并INFO随后调用来验证此行为。您会注意到used_memory_scripts_eval和number_of_cached_scripts指标会随着每个新脚本的执行而增长。

如上所述，动态生成的脚本是一种反模式。在应用程序运行时生成脚本可能会耗尽主机的内存资源来缓存它们。相反，脚本应该尽可能通用，并通过其参数提供自定义执行。

通过调用命令并提供其源代码，脚本将被加载到服务器的缓存中SCRIPT LOAD。服务器不会执行该脚本，而只是编译并加载到服务器的缓存中。加载后，您可以使用服务器返回的 SHA1 摘要执行缓存的脚本。

以下是加载并执行缓存脚本的示例：
```bash
redis> SCRIPT LOAD "return 'Immabe a cached script'"
"c664a3bf70bd1d45c4284ffebb65a6f2299bfc9f"

redis> EVALSHA c664a3bf70bd1d45c4284ffebb65a6f2299bfc9f 0
"Immabe a cached script"
```
注意：
Redis 脚本缓存始终是易失性的。它不被视为数据库的一部分，也不是持久的。服务器重新启动时、副本承担主角色时的故障转移期间或明确地清除缓存SCRIPT FLUSH。这意味着缓存的脚本是短暂的，缓存的内容可能随时丢失。

使用脚本的应用程序应始终调用EVALSHA以执行它们。如果脚本的 SHA1 摘要不在缓存中，服务器将返回错误。

## Lua API
Redis 包含一个嵌入式Lua 5.1解释器。该解释器运行用户定义的临时脚本和函数。脚本在沙盒上下文中运行，并且只能访问特定的 Lua 包。本页介绍了执行上下文中可用的包和 API。

### 全局变量和函数
沙盒 Lua 执行上下文会阻止声明全局变量和函数。阻止全局变量是为了确保脚本和函数不会尝试维护除 Redis 中存储的数据之外的任何运行时上下文。在需要在执行之间维护上下文（不太常见）的用例中，您应该将上下文存储在 Redis 的键空间中。
> 总结：不能使用全局变量和函数，不然要报错，即所有变量和函数定义都需要声明为本地。
例如：
```bash
local my_local_variable = 'some value'

local function my_local_function()
  -- Do something else, but equally amazing
end
```
> 注意：沙盒会尝试阻止全局变量的使用。使用 Lua 的调试功能或其他方法（例如更改用于实现全局变量保护的元表）来绕过沙盒并不难。但是，很难意外绕过保护。如果用户弄乱了 Lua 全局状态，则无法保证 AOF 和复制的一致性。换句话说，不要这样做。

### redis 单例
redis单例是一个可从所有脚本访问的对象实例。它提供了从脚本与 Redis 交互的 API。其输入是命令和参数，一旦调用，它将在 Redis 中执行该命令并返回答复。
常用命令：
- `redis.call()`  
- `redis.pcall()`  
...  
[具体参考文档](https://redis.io/docs/latest/develop/interact/programmability/lua-api/#redis_object)

### KEYS全局变量
自版本：2.6.0，脚本可用：是可用功能：否
> 重要提示： 为确保脚本在独立部署和集群部署中都能正确执行，函数访问的所有键的名称都必须明确提供为输入键参数。脚本应仅访问名称作为输入参数的键。脚本绝不应访问以编程方式生成的名称或基于数据库中存储的数据结构内容的键。

### ARGV全局变量
自版本：2.6.0，脚本可用：是，可用功能：否  
ARGV全局变量仅在临时脚本中可用。它已预先填充所有常规输入参数。